#include "stm32f10x.h"                  // Device header
#include "Track.h"
#include "mec_nav.h"
#include "GWKJ.h"
#include "math.h"

uint16_t Fhd[8]={0};//前八路灰度原始数据存放数组
uint16_t Bhd[8]={0};//后八路灰度原始数据存放数组

//前/后路灰度压线情况 CD：Condition，默认为F0/B0
int16_t FCD=0;
int16_t BCD=0;

int16_t FCD_0=0;
int16_t BCD_0=0;

//滤波后数据
int16_t F=0;
int16_t B=0;

//定义z轴旋转以及y轴平移的调控力度，用于输入开环运动函数
float r_z=0,t_y=0;
float r_z_0=0,t_y_0=0;
float r_z_1=0,t_y_1=0;

/*
前八路原始标号：87654321
后八路原始标号：12345678

第一次转化令两路标号对齐
Fhd:12345678
Bhd:12345678（该转化过程在）

第二次转化为压线情况
FCD/BCD：
-7:01111111
-6:00111111
-5:10111111
-4:10011111
-3:11011111
-2:11001111
-1:11101111
 0:11100111
 1:11110111
 2:11110011
 3:11111011
 4:11111001
 5:11111101
 6:11111100
 7:11111110

第三次转化为调控力度
旋转动作：FCD、BCD异号（前后路压线在异侧）
平移动作：FCD、BCD同号（前后路压线在同侧）
*/

/*取正负号函数*/
int8_t getsign(int8_t prem)
{
	if(prem>=0)
		return 1;
	else
		return -1;
}

uint8_t getabs(int8_t prem)
{
	if(prem>=0)
		return prem;
	else
		return -prem;
}

/*双八路巡线函数
 *RZ_TY为数组地址，传入数组地址后该函数算出最终的r_z,t_y后会装进主函数定义的数组中
 */
void Track(float *RZ_TY)
{
	//记录上一次数据
	FCD_0=FCD;
	BCD_0=BCD;
	
	//清零
	FCD=0;
	BCD=0;
	
	//记录上一次的调控值
	r_z_0 = r_z;
	t_y_0 = t_y;
	
	//记录上一次的调控值
	r_z_1 = r_z_0;
	r_z_1 = r_z_0;
	

	
	//临时求和变量
	uint8_t Fhd_sum=0,Bhd_sum=0;
	
	//a：旋转运动力度系数，b:z平移运动力度系数,a、b均为正
//	static float a=3,b=10;

	//将原始双路灰度数据取出
	GW_digital_Read_Array(Bhd);
	GW_digital_Read_Array2(Fhd);
	
	//去掉三路为0以及没有0的数据，即只考虑为1路压线和两路压线的情况
	for(int i=0;i<=7;i++)
	{
		Fhd_sum+=Fhd[i];
		Bhd_sum+=Bhd[i];
	}

	
	//前8路灰度
	if(Fhd_sum==7)//前灰度出现单0压线
	{
		for(int i=0;i<=7;i++)
		{
			if(Fhd[i]==0)
			{
//				if(i>=0&&i<=3)//左侧压线
//				{
					FCD = 2*i-7;//2*(-(5-(i+1)))+1将i从0、1、2、3转化为F-7、F-5、F-3、F-1
//				}
//				else if(i>=4&&i<=7)
//				{
//					FCD = 2*i-7;//2*(i-3)-1将将i从4、5、6、7转化为F1、F3、F5、F7
//				}
				break;//找到0后直接退出提高运行效率
			}
			
		}
	}
	else if(Fhd_sum==6)//前灰度出现双0压线
	{
		for(int i=0;i<=7;i++)
		{
			if(Fhd[i]==0&&Fhd[i+1]==0)
			{
//				if(i>=0&&i<=2)//左侧压线
//				{
					FCD = 2*i-6;//-2*(4-(i+1))将i、i+1从0\1、1\2、2\3转化为F-6、F-4、F-2
//				}
//				else if(i>=4&&i<=6)
//				{
//					FCD = 2*i-6;//2*((i+1)-4)将i、i+1从4\5、5\6、6\7转化为F2、F4、F6
//				}
				break;//找到0后直接退出提高运行效率
			}
			
		}
	}
	
	//后8路灰度
	if(Bhd_sum==7)//后灰度出现单0压线
	{
		for(int i=0;i<=7;i++)
		{
			if(Bhd[i]==0)
			{
				if(i>=0&&i<=3)//左侧压线
				{
					BCD = 2*i-7;//2*(-(5-(i+1)))+1将i从0、1、2、3转化为F-7、F-5、F-3、F-1
				}
				else if(i>=4&&i<=7)
				{
					BCD = 2*i-7;//2*(i-3)-1将将i从4、5、6、7转化为F1、F3、F5、F7
				}
				break;//找到0后直接退出提高运行效率
			}
			
		}
	}
	else if(Bhd_sum==6)//后灰度出现双0压线
	{
		for(int i=0;i<=7;i++)
		{
			if(Bhd[i]==0&&Bhd[i+1]==0)
			{
				if(i>=0&&i<=2)//左侧压线
				{
					BCD = 2*i-6;//-2*(4-(i+1))将i、i+1从0\1、1\2、2\3转化为F-6、F-4、F-2
				}
				else if(i>=4&&i<=6)//右侧压线
				{
					BCD = 2*i-6;//2*((i+1)-4)将i、i+1从4\5、5\6、6\7转化为F2、F4、F6
				}
				break;//找到0后直接退出提高运行效率
			}
			
		}
	}
	if(Bhd_sum==5)//后灰度出现三0压线
	{
		for(int i=0;i<=7;i++)
		{
			if(Bhd[i]==0)
			{
				if(i>=0&&i<=3)//左侧压线
				{
					BCD = 2*i-7;//2*(-(5-(i+1)))+1将i从0、1、2、3转化为F-7、F-5、F-3、F-1
				}
				else if(i>=4&&i<=7)
				{
					BCD = 2*i-7;//2*(i-3)-1将将i从4、5、6、7转化为F1、F3、F5、F7
				}
				break;//找到0后直接退出提高运行效率
			}
			
		}
	}
	else if(Bhd_sum==6)//后灰度出现双0压线
	{
		for(int i=0;i<=7;i++)
		{
			if(Bhd[i]==0&&Bhd[i+1]==0)
			{
				if(i>=0&&i<=2)//左侧压线
				{
					BCD = 2*i-6;//-2*(4-(i+1))将i、i+1从0\1、1\2、2\3转化为F-6、F-4、F-2
				}
				else if(i>=4&&i<=6)//右侧压线
				{
					BCD = 2*i-6;//2*((i+1)-4)将i、i+1从4\5、5\6、6\7转化为F2、F4、F6
				}
				break;//找到0后直接退出提高运行效率
			}
			
		}
	}

	F=0.5*FCD+0.5*FCD_0;
	B=0.5*BCD+0.5*BCD_0;
	
	//确定调控力度
		t_y=12*(FCD+BCD);//系数-b应为负值b=1.6
		r_z=16*(FCD-BCD);//a=1.2
	

	//分配当前值与上一次值的权重
	RZ_TY[0]=0.7*r_z+0.2*r_z_0+0.1*r_z_1;//Z轴旋转
	RZ_TY[1]=0.7*t_y+0.2*t_y_0+0.1*t_y_1;//Y轴平移
	
}







